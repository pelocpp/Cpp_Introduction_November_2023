Guten Morgen

Einführung in C++

Peter Loos

=====================================

So zwischen 12 und 13 Uhr

=====================================

C/C++    Java  C#  Mobile Programming

=====================================

2 Tools:

a) Visual Studio C++

b) Github: Repository - "Jungfern-Seminar"

   i)  Für dieses Seminar
   ii) Mit Vorlagen zum Kopieren / zum Nachschlagen (NEU)

Github:

https://github.com/pelocpp


Feedback:

== Vorrausetzungen

== Was sind meine Erwartungen

== Was fehlt ???


=== 10 Uhr / 17 Uhr:  FEEDBACK

=== Python // C# (Konzepte)

Lambda, 


=====================================

Hello - World.

=====================================

Klassen und Objekt

>> Daten

    e.g. Adresse

>> Funktionen // besser: Methoden

    changeAddress

OO Programmierung:
   Daten + Methoden (Funktion) zusammenzufassen
   in einem EINZIGEN Konstrukt


Klasse:  Beschreibung von Daten + Funktionen (Implementierung)

class Person

Ich will einen 'Person' haben:   Person hans;   // OBJEKT der KLASSE

OBJEKT synonym:  INSTANZ

=====================================

In C++: 2 Dateien

Anders als in C#, Java

Header-File  :  Description

Implementierungs-Datei:  Implementierung



=====================================

Beispiel:   Uhrzeit   // Time

Daten:

Stunden   //  Hours
Minuten   //  Minutes
Sekunden  //  Seconds

Methoden:

= Ausgabe in der Konsole (print)

= Eine Uhrzeit: Eine Sekunde weiterschlalten 

     increment  // move 1 second forward

     10:08:58   ==> 10:08:59      ==> 10:08:60  FALSCH  // Korrekt: 10:09:00      

= Vergleichen // compare

= reset: Alles Werte auf Null setzen

// =============================================

OO: Kennt einen Schutz von Daten  // Making Data secure

Access Rights:


// =============================================

Beispiel:

Programming STYLE

this : usage of this

I would prefer another programming STYLE


m_stunden:  member

stunden:    parameter

// =============================================

Pointer and References

C:   Pointer

C++: Reference

Beobachung: C ist in C++ enthalten ==> In C++ haben wir Pointer UND Referenzen

Wichtig bei dynamischem Speicher

-----------------------------------

void* malloc ( int size );


Frage: Wollen wir Speicher für int, double, Time, Rectangle, ....

Hack:  int*

Nein: Weil man nicht weiß, wofür der Speicher eigentlich ist:

     Aus Sicht von malloc:  void *  // Festlegung.


Wieviele Byte hat ein Rectangle:   sizeof (int)   sizeof (Rectangle)

// ======================================================

Was ist eine Referenz ???

What is a Reference

A) Es ist ein Alias-Name für eine andere Variable (Objekt)
   It's an alias (name) for another variable (object)

B) Intern:  Haben wir eine Adresse
   Intern:  We have an address

C) Schreibweise: EINFACHER als Pointer (Zeiger)
   Notation:     Simpler than Pointer - Syntax


=====================================

Wie kann ich statische Daten und die Klasse BankAccount zusammenführen ?

Wer vergibt eine Kontonummer ???

Die Sparkasse:

Information: Welche Kontonummer ist als nächstes verfügbar ???

Beispiel:  12345  ==> 12346

Frage:  Habe bereits viele BankAccount-Objekte ....


=====================================


Ich möchte zwei Konten vergleichen   // compare two accounts

A) Gleichheit:  Kontonummern sind gleich und Balance   // equal

b) Kleiner oder größer:  "Wer hat mehr Geld"   // who has more money  // less-than or greate-than


==>   Parameter


=====================================

Was ist eines der prinzipiellen Probleme von C++:

Es entstehen Kopien - an vielen Stellen, wo man es nicht möchte.
---------------------------------------------------------------

A) Die SW läuft (kein Fehler)

B) PERFORMANCE


Warum kennen zB Java und C# dieses Problem nicht ??????????

i) Java, C#,...  DON'T HAVE OBJECTS ON THE STACK

   Diese Sprachen kennen NUR DYNAMISCHE OBJEKTE  ( new, delete // malloc / free )

   HIER WERDEN NUR POINTER KOPIERT (KEINE DATENBEREICHE)



ii) C++ ist komplizierter als Java und C#


=====================================

Call-by-Reference:

A) Okay, ich kann auf dieses Weise auf das Original zugreifen.

b) Aber / UND: Diese Übergabe von Paramtern ist auch SCHNELLER  !!!!!!!!!!

BETTER PERFORMANCE.

=====================================


Error	C2662	'void BankAccount::deposit(double)': 


cannot convert 'this' pointer from 'const BankAccount' to 'BankAccount &'


=====================================

Was ist der tiefere Grund von 'const'

Gibt es da etwas Wichtiges ???

Ja:  Je mehr 'const' im Programm verwenden, umso besser kann der Compiler OPTIMIEREN !!!

Pipeling:  

=====================================

Der Adreßoperator & bei Referenzen

=====================================

    tmp = anInteger;
00007FF741E9A92B  mov         eax,dword ptr [anInteger]  
00007FF741E9A92E  mov         dword ptr [tmp],eax  

    tmp = rSomeRef;
00007FF741E9A931  mov         rax,qword ptr [rSomeRef]  
00007FF741E9A935  mov         eax,dword ptr [rax]  
00007FF741E9A937  mov         dword ptr [tmp],eax  


=====================================

Referenzen:

A) Ja, bitte verwenden

B) Es ist nur ein '&' am Datentyp notwendig.

C) mit 'const' kann ist das Original schützen.

D) Unter uns: geht auch ohne Referenz --- läuft etwas langsamer

================================================================

Beobachtung:

// comparison: Equality
if ( firstAccount.equals (secondAccount) == true ) {

    // sind gleich
}

// 
if ( firstAccount == secondAccount ) {

    // sind gleich
}

Überladen von Operatoren:  // Overloading of Operators
------------------------------------------------------

Time // Uhrzeit

Time t1, t2:

if (t1 == t2)

if (t1 < t2)


Wie geht das ???

A) Wir das Schreiben einer "normalen" Method

B) Was ist der Name dieser "normalen" Methode:  

    'operator' '=='  oder
    'operator' '<'  oder


Geht für fast alle Operatoren von C/C++:

Time = t1 + t2;


Achtung:

Ziel:

    if (t1 == t2) {

        std::cout << "Gleichheit";
    }

Würde ich eine equals-Methode verwenden:

    if (t1.equals (t2)) {

        std::cout << "Gleichheit";
    }


-----------------------------

A) Wenn ich der Besitzer der Klasse bin:

   Ich kann die Klasse erweitern ...

B) Ich bin NICHT der Besitzer der Klasse:

   Auch dann kann man Operatoren überladen:

   Als globale Funktionen :)


=========================================================

Feature: 

Friendship ===  VORSICHT.

Es werden alle PRIVATEN Daten für einen "Freund"

PUBLIC zur Verfügung gestellt.

=========================================================

Fazit:

Operatoren überladen:

A) In der Klasse

B) Als globale Funktion (friend)

=========================================================

Mittwoch:

Pascal   // Zeiger // Häubchen

=========================================================

Ich möchte Klassen mit DEMSELBEN Namen haben zB. für

  * Test
  * Prototyp-Entwicklung
  * Produktiv-Betrieb

Da kommt es zu KONFLIKTEN // Ambiguity 

Lösung: Klassen mit DEMSELBEN Namen in Namensräumen ablegen.

Warum ist das eine Lösung:

Die Klasse Rectangle heißt jetzt

AwesomeRectangle::Rectangle

oder

BeautifulRectangle::Rectangle

// ===============================================

Ein- / Ausgabe   // Input / Output

Konzept: Strom / Stream

== Schreiben in einen Strom
== Lesen aus einem Strom

Idee: Abstraktion

Strom:  Bildschirm (Konsole), Datei (File), Socket-Verbindung, Tastatur

Idee:  Eines "sprechenden" operators // Speaking identifier: 


int temperature;

Operators:  <<,  >>    // Symbolic:   Pfeil // Schreiben in einen Strom

Standard-Ströme // Standard- Streams:

Konsole:  std::cout

Keyboard: std::cin

============================================================

2 Tage:  Grundlagen gelernt

Standard Template Bibliothek (Library): STL

Zeichenketten:  "Viele Zeichen"

Konzepte der OO:    std::string

a) Konstruktoren:

   Mit einem Parameter: Konstante Zeichenkette

b) Operatoren:

   << für Ausgabe vorhanden.

c) getter:


   int <=== size ()     // getSize
   int <=== length ()   // getLength

   BESSER:

   size_t <=== size ()     // getSize
   size_t <=== length ()   // getLength


   bool  <=== empty();

Was ist size_t ???

Historie:   Eine Länge wie 10 Zeichen entspricht einem ganzzahligen Wert

            int :

            Puristen: ein int kann einen negativen Wert haben.

            Lösing: Man hat in der "Neuzeit": Man wähle einen

            integralen Datentyp OHNE Vorzeichen:  vorzeichenlos

            unsigned int
            size_t == unsigned __int64

== Methoden:

insert   // einfügen

replace  // ersetzen

append   // anhängen


substr   // Eine Teilzeichenkette bestimmen  (  von ... wie viele // from .. count)

== Operator: Verleichsoperator // Comparison Operator

   Test auf Gleichheit: Test for equality

[] Operator: Index-Operator

+ - Operator: to concatenate two strings // 2 Zeichenketten aneinanderhängen

// append: Geht auch mit append:

Oft: SAME Functionality either with a method or an operator

     ( eqals // operator ==  )

=====================================

Dynamische Speicherverwaltung:

new   ==>   1 Variable
new[N] ==>  N Variables   N muss konstant sein

Ich erhalte in beiden Fällen einen Zeiger:

int *ip;

INTERESSANTES SPRACHFEATURE:

Mit einem Zeiger (Anfangsadresse) kann ich SYNTAKTISCH
wie mit einem Feld (Array) arbeiten:

With a pointer i can work the same way like with an array:

==================================================

By the way:

Maschinenraum von C++

==================================================

Es gibt new in 2 Ausprägungen:

new    ==>   1 Variable    scalar new
new[N] ==>   N Variables   array new

Es gibt delete in 2 Ausprägungen:

delete ptr;      // <=== scalar new  
delete[] ptr;    // <=== array new  

==================================================

C++ ist eine der kompliziertesten Sprachen.

Ein Beispiel:

a) calling new[]
b) calling delete (according to new[])

UB

Undefined Behaviour

===========================================================

Eine Anwendung // ein Gebrauch von dynamischen Daten:

new-Aufruf:  Zeiger (Halde)

Beispiel:

Ein - in C/C++ eingebautes Feld:

int numbers[10];    // built-in array

FIXED SIZE

Lösung für ein Feld dynamischer Länge: wir schreiben eine Klasse.

AChtung:

Neben dem Konstruktor benötigen wir einen Destuktor:

Um den mit new belegten Speicherplatz freizugeben !!!

Der Aufruf des Destruktors wird AUTOMATISCH abgesetzt !!!

Zugriff auf die Daten des dynamischen Arrays:

Mit at.

"Here references are shining"


"Here operator overloading is shining"

// ================================================

Heap:

How is the heap managed ?????????????????????

== Simple: By us  // with the help of new and delete.


Destructor:

How are the Destructor calls managed ?????????????????????

== Automatically: The calls are generated automatically.

== BUT: The contents of the Destructor: we are responsible.

// ================================================

Lifetime  // Lebenszeit von Objekten:

A) Globales Objekt:

Konstruktoren werden VOR main gerufen.
Destruktoren werden NACH main gerufen.

B) Lokales Objekt:

Konstruktoren werden bei Objekterzeugung gerufen.
Destruktoren werden am Ende des Blocks gerufen.

C) Dynamisches Objekt:

Konstruktoren werden bei der Objekterzeugung mit NEW gerufen.
Destruktoren werden beim Aufruf von delete gerufen.

// ================================================
